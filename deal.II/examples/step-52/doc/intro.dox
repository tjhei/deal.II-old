<br>

<i>This program was contributed by Bruno Turcksin and Damien Lebrun-Grandie.</i>

<a name="Intro"></a>
<h1>Introducion</h1>

This program shows how to use Runge-Kutta methods to solve a time-dependent
problem.

<h3>Problem statement</h3>

In this example, we solve the one-group time-dependent diffusion
approximation of the neutron transport equation (see step-28 for the
time-independent multigroup diffusion). We assume that the medium is not
fissible and therefore, the neutron flux satisfies the following equation:
@f{eqnarray*}
\frac{1}{v}\frac{\partial \phi(x,t)}{\partial t} = \nabla D(x) \nabla \phi(x,t)
- \Sigma_a(x) \phi(x,t) + S(x,t)
@f}
augmented by appropriate boundary conditions. Here, $v$ is the velocity of
neutrons (for simplicity we assume it is equal to 1), $D$ is the diffusion coefficient, 
$\Sigma_a$ is the absorption cross section, and $S$ is a source. Because we are
only interested in the time dependence, we assume that $D$ and $\Sigma_a$ are
constant. We are looking for a solution on a square domain $[0,b]\times[0,b]$ of
the form:
@f{eqnarray*}
\phi(x,t) = A\sin(\omega t)(bx-x^2).
@f}
By using quadratic finite elements, all the error will be due to the time discretization. We
impose the following boundary conditions: homogeneous Dirichlet for $x=0$ and
$x=b$ and homogeneous Neumann conditions for $y=0$ and $y=b$. The source is
given by:
@f{eqnarray*}
S=A\left(\frac{1}{v}\omega \cos(\omega t)(bx -x^2) + \sin(\omega t)
\left(\Sigma_a (bx-x^2)+2D\right) \right).
@f}
Because the solution is a sine, we know that $\phi\left(x,\pi\right) = 0$.
Therefore, the error at this time is simply the norm of the numerical solution.

<h3>Runge-Kutta</h3>

The Runge-Kutta methods implemented in deal.II assume that the equation to be
solved can be written as:
@f{eqnarray*}
\frac{dy}{dt} = f(t,y).
@f}
When using finite elements, the previous equation becomes:
@f{eqnarray*}
M\frac{dy}{dt} = f(t,y),
@f}
where $M$ is the mass matrix. Therefore, we have:
@f{eqnarray*}
\frac{dy}{dt} = M^{-1}f(t,y).
@f}
Runke-Kutta methods can be written as:
@f{eqnarray*}
y_{n+1} = y_n + \sum_{i=1}^s b_i k_i
@f}
where
@f{eqnarray*}
k_i = h M^{-1} f\left(t_n+c_ih,y_n+\sum_{j=1}^sa_{ij}k_j\right)
@f}
with $a_{ij}$, $b_i$, and $c_i$ are known coefficient and $h$ is the time step
used. At the time of the writing of this tutorial, the methods implemented in
deal.II can be divided in three categories:
<ol>
<li> explicit Runge-Kutta
<li> embedded (or adaptive) Runge-Kutta
<li> implicit Runge-Kutta
</ol> 

<h4>Explicit Runge-Kutta</h4>
These methods that include forward Euler, third order Runge-Kutta, and
fourth order Runge-Kutta, require a function to evaluate $M^{-1}f(t,y)$. These
methods become unstable when the time step chosen is too large.

<h4>Embedded Runge-Kutta</h4>
These methods include Heun-Euler, Bogacki-Shampine, Dormand-Prince (ode45 in
Matlab), Fehlberg, and Cash-Karp. These methods use a low order method to
estimate the error and decide if the time step needs to be refined or coarsen. 
Only embedded explicit methods have been implemented at the time of the writing.

<h4>Implicit Runge-Kutta</h4>
These methods include backward Euler, implicit midpoint, Crank-Nicolson, and a
two stages SDIRK. These methods require to evaluate $M^{-1}f(t,y)$ and
$\left(I-\Delta t M^{-1} \frac{\partial f}{\partial y}\right)^{-1}$ or equivalently 
$\left(M - \Delta t \frac{\partial f}{\partial y}\right)^{-1} M$. These methods are 
always stable.

<h3>Weak form</h3>
To use the Runge-Kutta methods, we need to be able to evaluate:
@f{eqnarray*}
f = \oint D b_i \frac{\partial b_j}{\partial n} d\boldsymbol{r} - \int D \nabla
b_i \nabla b_j \phi_j d\boldsymbol{r} -\int \Sigma_a b_i b_j \phi_j 
d\boldsymbol{r} + \int b_j S d\boldsymbol{r}
@f}
and $\frac{\partial f}{\partial y}$. Because $f$ is linear in $y$ (or $\phi$ in
this case) $\frac{\partial f}{\partial y} y = f$.

<h3>Remarks</h3>
To simplify the problem, the domain is two dimensional and the mesh is
uniform (there is no need to adapt the mesh since we use quadratic finite
elements and the exact solution is quadratic). Going from a two dimensional
domain to a three dimensional domain is not very challenging. However if the
mesh must be adapted, it is important to remember to:
<ol>
<li> project the solution to the new mesh when the mesh is changed. The mesh
used should be the same at the beginning and at the end of the time step.
<li> update the mass matrix and its inverse.
</ol>
