<a name="Intro"></a>
<h1>Introduction</h1>


<H3><A NAME="SECTION00001000000000000000">
Overview</A>
</H3>
This example is devoted to the <EM>discontinuous Galerkin method</EM>, or
in short: DG method. It treats following topics.
<UL>
<LI>Discretization of the linear transport equation with the DG method
<LI>Two different assembling routines of the system matrix based on face terms given
<DL COMPACT>
<DT>1.
<DD>as a sum of integrals over all cell boundaries, and
<DT>2.
<DD>as a sum of integrals over all faces.
</DL>
<LI>Time comparison of the two assembling routines.
</UL>
<P>

<H3><A NAME="SECTION00002000000000000000">
Introduction</A>
</H3>
The DG method was first introduced to discretize simple transport
equations. Over the past years DG methods have been applied to a
variety of problems and many different schemes were introduced
employing a big zoo of different convective and diffusive fluxes.  As
this example's purpose is to illustrate some implementational issues
of the DG discretization only, here we simply consider the linear
transport equation
<BR><P></P>
<DIV ALIGN="CENTER">

<!-- MATH: \begin{equation}
\nabla\cdot \left\{\beta u\right\}=f  \qquad\mbox{in }\Omega,
\end{equation} -->

<TABLE WIDTH="100%" ALIGN="CENTER">
<TR VALIGN="MIDDLE"><TD ALIGN="CENTER" NOWRAP><A NAME="transport-equation">&#160;</A><IMG
 WIDTH="170" HEIGHT="31"
 SRC="step-12.data/img2.gif"
 ALT="\begin{displaymath}
\nabla\cdot \left\{\beta u\right\}=f \qquad\mbox{in }\Omega,
\end{displaymath}"></TD>
<TD WIDTH=10 ALIGN="RIGHT">
(1)</TD></TR>
</TABLE>
</DIV>
<BR CLEAR="ALL"><P></P>
subject to the boundary conditions
<BR><P></P>
<DIV ALIGN="CENTER">
<!-- MATH: \begin{displaymath}
u=g\quad\mbox{on }\partial\Omega_-.
\end{displaymath} -->


<IMG
 WIDTH="122" HEIGHT="31"
 SRC="step-12.data/img3.gif"
 ALT="\begin{displaymath}u=g\quad\mbox{on }\partial\Omega_-.
\end{displaymath}">
</DIV>
<BR CLEAR="ALL">
<P></P>
Here, 
<!-- MATH: $\beta=\beta(x)$ -->
<IMG
 WIDTH="73" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="step-12.data/img4.gif"
 ALT="$\beta=\beta(x)$">
is a vector field, <I>f</I> a source function, <I>u</I> the
(scalar) solution function, <I>g</I> a boundary value function and
<BR><P></P>
<DIV ALIGN="CENTER">
<!-- MATH: \begin{displaymath}
\partial\Omega_-:=\{x\in\partial\Omega, \beta(x)\cdot n(x)<0\}
\end{displaymath} -->


<IMG
 WIDTH="254" HEIGHT="31"
 SRC="step-12.data/img5.gif"
 ALT="\begin{displaymath}\partial\Omega_-:=\{x\in\partial\Omega, \beta(x)\cdot n(x)<0\}
\end{displaymath}">
</DIV>
<BR CLEAR="ALL">
<P></P>
the inflow boundary of the domain, whereas <I>n</I> denotes the unit outer
normal to boundary 
<!-- MATH: $\partial\Omega$ -->
<IMG
 WIDTH="27" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="step-12.data/img6.gif"
 ALT="$\partial\Omega$">
of the domain. This equation,
(<A HREF="step-12.html#transport-equation">1</A>), is the conservative version of the
transport equation already considered in step 9 of this tutorial.

<H3><A NAME="SECTION00003000000000000000">
Discretization</A>
</H3>
To follow the general theory of deriving DG discretizations for purely
hyperbolic equations we first consider the general hyperbolic problem
<BR><P></P>
<DIV ALIGN="CENTER">
<!-- MATH: \begin{displaymath}
\nabla\cdot F(u)=f  \qquad\mbox{in }\Omega,
\end{displaymath} -->


<IMG
 WIDTH="170" HEIGHT="31"
 SRC="step-12.data/img7.gif"
 ALT="\begin{displaymath}\nabla\cdot F(u)=f \qquad\mbox{in }\Omega,
\end{displaymath}">
</DIV>
<BR CLEAR="ALL">
<P></P>
subject to appropriate boundary conditions. Here <I>F</I> denotes the flux
function of the equation under consideration that for in our case, see equation,
(<A HREF="step-12.html#transport-equation">1</A>), is represented by 
<!-- MATH: $F(u)=\beta u$ -->
<IMG
 WIDTH="86" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="step-12.data/img8.gif"
 ALT="$F(u)=\beta u$">.
For
deriving the DG discretization we start with a variational,
mesh-dependent formulation of the problem,
<BR><P></P>
<DIV ALIGN="CENTER">
<!-- MATH: \begin{displaymath}
\sum_K\left\{-(F(u),\nabla v)_K+(F(u)\cdot n, v)_{\partial K}\right\}=(f,v)_\Omega,
\end{displaymath} -->


<IMG
 WIDTH="363" HEIGHT="50"
 SRC="step-12.data/img9.gif"
 ALT="\begin{displaymath}\sum_K\left\{-(F(u),\nabla v)_K+(F(u)\cdot n, v)_{\partial K}\right\}=(f,v)_\Omega,
\end{displaymath}">
</DIV>
<BR CLEAR="ALL">
<P></P>
that originates from (<A HREF="step-12.html#transport-equation">1</A>) by multiplication with
a test function and integration by parts on each cell <I>K</I> of the
triangulation. Here 
<!-- MATH: $(\cdot, \cdot)_K$ -->
<IMG
 WIDTH="49" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="step-12.data/img10.gif"
 ALT="$(\cdot, \cdot)_K$">
and 
<!-- MATH: $(\cdot, \cdot)_{\partial
K}$ -->
<IMG
 WIDTH="57" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="step-12.data/img11.gif"
 ALT="$(\cdot, \cdot)_{\partial
K}$">
simply denote the integrals over the cell and the boundary of
the cell, respectively. To discretize the problem, the functions <I>u</I>and <I>v</I> are replaced by discrete functions <I>u</I><SUB><I>h</I></SUB> and <I>v</I><SUB><I>h</I></SUB> that in the
case of discontinuous Galerkin methods belong to the space <I>V</I><SUB><I>h</I></SUB> of
discontinuous piecewise polynomial functions of some degree <I>p</I>. Due
to the discontinuity of the discrete function <I>u</I><SUB><I>h</I></SUB> on interelement
faces, the flux 
<!-- MATH: $F(u)\cdot n$ -->
<IMG
 WIDTH="65" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="step-12.data/img12.gif"
 ALT="$F(u)\cdot n$">
must be replaced by a <EM>numerical
  flux</EM> function 
<!-- MATH: $H(u_h, \hat u_h, n)$ -->
<IMG
 WIDTH="97" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="step-12.data/img13.gif"
 ALT="$H(u_h, \hat u_h, n)$">,
where 
<!-- MATH: $u_h|_{\partial K}$ -->
<IMG
 WIDTH="49" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="step-12.data/img14.gif"
 ALT="$u_h\vert _{\partial K}$">denotes the inner trace (w.r.t.  the cell <I>K</I>) of <I>u</I><SUB><I>h</I></SUB> and 
<!-- MATH: $\hat
u_h|_{\partial K}$ -->
<IMG
 WIDTH="49" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="step-12.data/img15.gif"
 ALT="$\hat
u_h\vert _{\partial K}$">
the outer trace, i.e. the value of <I>u</I><SUB><I>h</I></SUB> on the
neighboring cell. Furthermore the numerical flux function <I>H</I>, among
other things, is consistent, i.e.
<BR><P></P>
<DIV ALIGN="CENTER">
<!-- MATH: \begin{displaymath}
H(u,u,n)=F(u)\cdot n,
\end{displaymath} -->


<IMG
 WIDTH="162" HEIGHT="31"
 SRC="step-12.data/img16.gif"
 ALT="\begin{displaymath}H(u,u,n)=F(u)\cdot n,
\end{displaymath}">
</DIV>
<BR CLEAR="ALL">
<P></P>
and conservative, i.e.
<BR><P></P>
<DIV ALIGN="CENTER">

<!-- MATH: \begin{equation}
H(v,w,n)=-H(w,v,-n).
\end{equation} -->
<A NAME="conservative">&#160;</A>
<TABLE WIDTH="100%" ALIGN="CENTER">
<TR VALIGN="MIDDLE"><TD ALIGN="CENTER" NOWRAP>
<I>H</I>(<I>v</I>,<I>w</I>,<I>n</I>)=-<I>H</I>(<I>w</I>,<I>v</I>,-<I>n</I>).
</TD>
<TD WIDTH=10 ALIGN="RIGHT">
(2)</TD></TR>
</TABLE>
</DIV>
<BR CLEAR="ALL"><P></P>
This yields the following <EM>discontinuous Galerkin
  discretization</EM>: find 
<!-- MATH: $u_h\in V_h$ -->
<IMG
 WIDTH="63" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="step-12.data/img17.gif"
 ALT="$u_h\in V_h$">
such that
<BR><P></P>
<DIV ALIGN="CENTER">

<!-- MATH: \begin{equation}
\sum_K\left\{-(F(u_h),\nabla v_h)_K+(H(u_h,\hat u_h,n), v_h)_{\partial K}\right\}=(f,v)_\Omega, \quad\forall v_h\in V_h.
\end{equation} -->

<TABLE WIDTH="100%" ALIGN="CENTER">
<TR VALIGN="MIDDLE"><TD ALIGN="CENTER" NOWRAP><A NAME="dg-scheme">&#160;</A><IMG
 WIDTH="513" HEIGHT="50"
 SRC="step-12.data/img18.gif"
 ALT="\begin{displaymath}
\sum_K\left\{-(F(u_h),\nabla v_h)_K+(H(u_h,\hat u_h,n), v_h)_{\partial K}\right\}=(f,v)_\Omega, \quad\forall v_h\in V_h.
\end{displaymath}"></TD>
<TD WIDTH=10 ALIGN="RIGHT">
(3)</TD></TR>
</TABLE>
</DIV>
<BR CLEAR="ALL"><P></P>
Boundary conditions are realized by replacing <IMG
 WIDTH="23" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="step-12.data/img19.gif"
 ALT="$\hat u_h$">
on the inflow boundary 
<!-- MATH: $\partial\Omega_-$ -->
<IMG
 WIDTH="39" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="step-12.data/img20.gif"
 ALT="$\partial\Omega_-$">
by the boundary function <I>g</I>.
In the special case of the transport equation
(<A HREF="step-12.html#transport-equation">1</A>) the numerical flux in its simplest form
is given by
<BR><P></P>
<DIV ALIGN="CENTER">

<!-- MATH: \begin{equation}
H(u_h,\hat u_h,n)(x)=\left\{\begin{array}{ll}
      (\beta\cdot n\, u_h)(x),&\mbox{for } \beta(x)\cdot n(x)<0,\\
      (\beta\cdot n\, \hat u_h)(x),&\mbox{for } \beta(x)\cdot n(x)\geq 0.
\end{array}
\right.
\end{equation} -->

<TABLE WIDTH="100%" ALIGN="CENTER">
<TR VALIGN="MIDDLE"><TD ALIGN="CENTER" NOWRAP><A NAME="flux-transport-equation">&#160;</A><IMG
 WIDTH="417" HEIGHT="50"
 SRC="step-12.data/img21.gif"
 ALT="\begin{displaymath}
H(u_h,\hat u_h,n)(x)=\left\{\begin{array}{ll}
(\beta\cdot ...
...)(x),&\mbox{for } \beta(x)\cdot n(x)\geq 0.
\end{array}\right.
\end{displaymath}"></TD>
<TD WIDTH=10 ALIGN="RIGHT">
(4)</TD></TR>
</TABLE>
</DIV>
<BR CLEAR="ALL"><P></P>
Hence, the discontinuous Galerkin scheme for the transport equation
(<A HREF="step-12.html#transport-equation">1</A>) is given by: find 
<!-- MATH: $u_h\in V_h$ -->
<IMG
 WIDTH="63" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="step-12.data/img17.gif"
 ALT="$u_h\in V_h$">
such that for all 
<!-- MATH: $v_h\in V_h$ -->
<IMG
 WIDTH="62" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="step-12.data/img22.gif"
 ALT="$v_h\in V_h$">
following equation holds:
<BR>
<A NAME="dg-transport">&#160;</A><IMG
 WIDTH="534" HEIGHT="66" ALIGN="BOTTOM" BORDER="0"
 SRC="step-12.data/img23.gif"
 ALT="\begin{multline}
\sum_K\left\{-(u_h,\beta\cdot\nabla v_h)_K+(\beta\cdot n\, u_h...
...ht\}\\
=(f,v)_\Omega-(\beta\cdot n\, g, v_h)_{\partial\Omega_-},
\end{multline}">
<BR>
where 
<!-- MATH: $\partial K_-:=\{x\in\partial K, \beta(x)\cdot n(x)<0\}$ -->
<IMG
 WIDTH="263" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="step-12.data/img24.gif"
 ALT="$\partial K_-:=\{x\in\partial K, \beta(x)\cdot n(x)<0\}$">
denotes
the inflow boundary and 
<!-- MATH: $\partial K_+=\partial K\setminus \partial
K_-$ -->
<IMG
 WIDTH="143" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="step-12.data/img25.gif"
 ALT="$\partial K_+=\partial K\setminus \partial
K_-$">
the outflow part of cell <I>K</I>. This equation will be
refered to as <EM>first version</EM> of the DG method in the following. We
note that after integrating by parts again, we end up with: find

<!-- MATH: $u_h\in V_h$ -->
<IMG
 WIDTH="63" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="step-12.data/img17.gif"
 ALT="$u_h\in V_h$">
such that
<BR><P></P>
<DIV ALIGN="CENTER">
<!-- MATH: \begin{displaymath}
\sum_K\left\{(\nabla\cdot\{\beta u_h\},\nabla v_h)_K-(\beta\cdot n [u_h], v_h)_{\partial K_-}\right\}=(f,v)_\Omega, \quad\forall v_h\in V_h,
\end{displaymath} -->


<IMG
 WIDTH="509" HEIGHT="50"
 SRC="step-12.data/img26.gif"
 ALT="\begin{displaymath}\sum_K\left\{(\nabla\cdot\{\beta u_h\},\nabla v_h)_K-(\beta\c...
..._{\partial K_-}\right\}=(f,v)_\Omega, \quad\forall v_h\in V_h,
\end{displaymath}">
</DIV>
<BR CLEAR="ALL">
<P></P>
where 
<!-- MATH: $[u_h]=u_h-\hat u_h$ -->
<IMG
 WIDTH="114" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="step-12.data/img27.gif"
 ALT="$[u_h]=u_h-\hat u_h$">
denotes the jump of the discrete function
between two neighboring cells, that on the boundary of the domain is defined to be 
<!-- MATH: $[u_h]=u_h-g$ -->
[<I>u</I><SUB><I>h</I></SUB>]=<I>u</I><SUB><I>h</I></SUB>-<I>g</I>. This is the discontinuous Galerkin
scheme for the transport equation given in its original notation.
Nevertheless, we will base the implementation of the scheme on the form
given by (<A HREF="step-12.html#dg-scheme">3</A>) and (<A HREF="step-12.html#flux-transport-equation">4</A>), or
(<A HREF="step-12.html#dg-transport">5</A>), respectively.

<P>
Finally we rewrite (<A HREF="step-12.html#dg-scheme">3</A>) in terms of a summation over all faces 
where each face 
<!-- MATH: $\Gamma=\partial
K\cap\partial \hat K$ -->
<IMG
 WIDTH="111" HEIGHT="21" ALIGN="BOTTOM" BORDER="0"
 SRC="step-12.data/img28.gif"
 ALT="$\Gamma=\partial
K\cap\partial \hat K$">
between two neighboring cells <I>K</I> and <IMG
 WIDTH="21" HEIGHT="21" ALIGN="BOTTOM" BORDER="0"
 SRC="step-12.data/img29.gif"
 ALT="$\hat K$">occurs twice: Find 
<!-- MATH: $u_h\in V_h$ -->
<IMG
 WIDTH="63" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="step-12.data/img17.gif"
 ALT="$u_h\in V_h$">
such that
<BR><P></P>
<DIV ALIGN="CENTER">

<!-- MATH: \begin{equation}
-\sum_K(F(u_h),\nabla v_h)_K+\sum_\Gamma\left\{(H(u_h,\hat u_h,n), v_h)_\Gamma+(H(\hat u_h, u_h,-n), \hat v_h)_{\Gamma\setminus\partial\Omega}\right\}=(f,v)_\Omega \quad\forall v_h\in V_h,
\end{equation} -->

<TABLE WIDTH="100%" ALIGN="CENTER">
<TR VALIGN="MIDDLE"><TD ALIGN="CENTER" NOWRAP><A NAME="dg-scheme-faces-long">&#160;</A><IMG
 WIDTH="723" HEIGHT="50"
 SRC="step-12.data/img30.gif"
 ALT="\begin{displaymath}
-\sum_K(F(u_h),\nabla v_h)_K+\sum_\Gamma\left\{(H(u_h,\hat ...
...s\partial\Omega}\right\}=(f,v)_\Omega \quad\forall v_h\in V_h,
\end{displaymath}"></TD>
<TD WIDTH=10 ALIGN="RIGHT">
(5)</TD></TR>
</TABLE>
</DIV>
<BR CLEAR="ALL"><P></P>
By employing conservativity (<A HREF="step-12.html#conservative">2</A>) of the numerical flux
this equation simplifies to: find 
<!-- MATH: $u_h\in V_h$ -->
<IMG
 WIDTH="63" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="step-12.data/img17.gif"
 ALT="$u_h\in V_h$">
such that
<BR><P></P>
<DIV ALIGN="CENTER">

<!-- MATH: \begin{equation}
-\sum_K(F(u_h),\nabla v_h)_K+\sum_\Gamma(H(u_h,\hat u_h,n), [v_h])_{\Gamma\setminus\partial\Omega}+\sum_\Gamma(H(u_h,\hat u_h,n), v_h)_{\Gamma\cap\partial\Omega}=(f,v)_\Omega \quad\forall v_h\in V_h.
\end{equation} -->

<TABLE WIDTH="100%" ALIGN="CENTER">
<TR VALIGN="MIDDLE"><TD ALIGN="CENTER" NOWRAP><A NAME="dg-scheme-faces">&#160;</A><IMG
 WIDTH="748" HEIGHT="50"
 SRC="step-12.data/img31.gif"
 ALT="\begin{displaymath}
-\sum_K(F(u_h),\nabla v_h)_K+\sum_\Gamma(H(u_h,\hat u_h,n),...
...Gamma\cap\partial\Omega}=(f,v)_\Omega \quad\forall v_h\in V_h.
\end{displaymath}"></TD>
<TD WIDTH=10 ALIGN="RIGHT">
(6)</TD></TR>
</TABLE>
</DIV>
<BR CLEAR="ALL"><P></P>
Whereas the outer unit normal

<!-- MATH: $n|_{\partial K}$ -->
<IMG
 WIDTH="41" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="step-12.data/img32.gif"
 ALT="$n\vert _{\partial K}$">
is uniquely defined this is not so for <IMG
 WIDTH="24" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="step-12.data/img33.gif"
 ALT="$n_\Gamma$">.
<IMG
 WIDTH="24" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="step-12.data/img33.gif"
 ALT="$n_\Gamma$">
might be the normal from
either side of the face. Hence, we need to fix the normal <I>n</I> on the face to
be one of the two normals and denote the other normal by
-<I>n</I>. This way we get -<I>n</I> in the second face term in
(<A HREF="step-12.html#dg-scheme-faces-long">6</A>) that finally produces the minus sign in
the jump [<I>v</I><SUB><I>h</I></SUB>] in equation (<A HREF="step-12.html#dg-scheme-faces">7</A>).

<P>
For the linear transport equation (<A HREF="step-12.html#transport-equation">1</A>) this
equation (<A HREF="step-12.html#dg-scheme-faces">7</A>) simplifies to
<BR>
<A NAME="dg-transport-gamma">&#160;</A><IMG
 WIDTH="534" HEIGHT="66" ALIGN="BOTTOM" BORDER="0"
 SRC="step-12.data/img34.gif"
 ALT="\begin{multline}
-\sum_K(u_h,\beta\cdot\nabla v_h)_K+\sum_\Gamma\left\{(\beta\c...
...ht\}\\
=(f,v)_\Omega-(\beta\cdot n\, g, v_h)_{\partial\Omega_-},
\end{multline}">
<BR>
what will be refered to as <EM>second version</EM> of the DG method.

<H3><A NAME="SECTION00004000000000000000">
Implementation</A>
</H3>
As already mentioned at the beginning of this example we will
implement the assembling of the system matrix in two different ways.
The first one will be based on the first version (<A HREF="step-12.html#dg-transport">5</A>)
of the DG method that includes a sum of integrals over all cell
boundaries 
<!-- MATH: $\partial K$ -->
<IMG
 WIDTH="31" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="step-12.data/img35.gif"
 ALT="$\partial K$">.
This is realized by a loop over all cells and
a nested loop over all faces of each cell.  Thereby each inner face

<!-- MATH: $\Gamma=\partial K\cap\partial \hat K$ -->
<IMG
 WIDTH="111" HEIGHT="21" ALIGN="BOTTOM" BORDER="0"
 SRC="step-12.data/img28.gif"
 ALT="$\Gamma=\partial
K\cap\partial \hat K$">
is treated twice, the first
time when the outer loop treats cell <I>K</I> and the second time when it
treats cell <IMG
 WIDTH="21" HEIGHT="21" ALIGN="BOTTOM" BORDER="0"
 SRC="step-12.data/img29.gif"
 ALT="$\hat K$">.
This way some values like the shape function
values at quadrature points on faces need to be computed twice.

<P>
To overcome this overhead and for comparison, we implement the
assembling of a matrix also in a second and different way. This will
be based on the second version (<A HREF="step-12.html#dg-transport-gamma">8</A>) that
includes a sum of integrals over all faces <IMG
 WIDTH="15" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="step-12.data/img36.gif"
 ALT="$\Gamma$">.
Here, several
difficulties occur.
<UL>
<LI>As degrees of freedom are associated to cells (and not to faces)
  and as a normal is only defined w.r.t a cell adjacent to the face we
  cannot simply run over all faces of the triangulation but need to
  perform the nested loop over all cells and all faces of each cell
  like in the first implementation.  This, because in <EM>deal.II</EM>
  faces are accessible from cells but not visa versa.
<LI>Due to the nested loop we arrive twice at each face. In order to
  assemble the face terms only once we either need to track which
  faces we have treated before, or we introduce a simple rule that decides
  which of the two adjacent cells the face should be accessed and
  treated from.  Here, we employ the second approach and define the
  following rule:
  <DL COMPACT>
<DT>a)
<DD>If the two cells adjacent to a face are of the same refinement level we access and treat the face from the cell with lower index.
<DT>b)
<DD>If the two cells are of different refinement levels we access
    and treat the face from the coarser cell.
  </DL></UL>Before we start with the description of the code we first introduce
its main ingredients. The main class is called
<EM>DGMethod</EM>. It comprises all basic objects like the
triangulation, the dofhandler, the system matrix and solution vectors.
Furthermore it has got some member functions, the most prominent of
which are the <EM>assemble_system1</EM> and <EM>assemble_system2</EM>
functions that implement the two different ways mentioned above for
assembling the system matrix. Within these assembling routines several
different cases must be distinguished while performing the nested
loops over all cells and all faces of each cell and assembling the
respective face terms. While sitting on the current cell and looking
at a specific face there are the cases
<DL COMPACT>
<DT>1.
<DD>face is at boundary,
<DT>2.
<DD>neighboring cell is finer,
<DT>3.
<DD>neighboring cell is of the same refinement level, and
<DT>4.
<DD>neighboring cell is coarser
</DL>where `neighboring cell' denotes one of the two cells adjacent to the
face which is not the current cell. In all these cases the assembling
of the face terms are either the same or similar to each other. Hence,
we can implement the assembling of the face terms either by `copy and
paste' (the lazy way, that revenges not later than the scheme or the
equation might want to be changed afterwards) or by calling a separate
function that covers all four cases. To be a bit educational within
this tutorial we perform the latter approach, of course. We go even
further and encapsulate this function and everything that is needed
for assembling the specific equation under consideration within a
class called <EM>DGTransportEquation</EM>. This class includes objects
of all equation-specific functions, as there are the <EM>RHS</EM> and
the <EM>BoundaryValues</EM> class, both derived from the <EM>Function</EM>
class, and the <EM>Beta</EM> class representing the vector field.
Furthermore the <EM>DGTransportEquation</EM> class comprises member
functions <EM>assemble_face_terms1</EM> and
<EM>assemble_face_terms2</EM> that are invoked by the
<EM>assemble_system1</EM> and <EM>assemble_system2</EM> functions of the
<EM>DGMethod</EM>, respectively, and the function
<EM>assemble_cell_term</EM> that is the same for both assembling
routines.  The <EM>DGTransportEquation</EM> class can then easily be
replaced by a different class that implements a different equation and
a different DG method. Indeed, the implementation of the
<EM>assemble_system1</EM> and <EM>assemble_system2</EM> functions will
be general enough to serve for different DG methods, different
equations, even for systems of equations (!) and, under small
modifications, for nonlinear problems.
